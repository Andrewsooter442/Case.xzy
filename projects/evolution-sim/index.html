<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Evolution-Sim | ByteCase</title><link rel=stylesheet href=/Style/Contact.css><link rel=stylesheet href=/Style/Default.css><link rel=stylesheet href=/Style/Projects.css><link rel=stylesheet href=/Style/style.css><link rel=stylesheet href=/Style/icons.css><link rel=stylesheet href=/Style/syntax.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css><script>(function(){const e=localStorage.getItem("theme"),t=document.documentElement;e&&t.setAttribute("data-theme",e)})()</script></head><body><div class=app_container><aside class=sidebar><div class=sidebar_header><a href=https://summer.xyz/ class=site_title><h1>ByteCase</h1></a><button id=theme-toggle aria-label="Toggle Dark Mode" style="background:0 0;border:none;cursor:pointer;color:var(--text-color);font-size:1.2rem;padding:.5rem">
<i class="fa-solid fa-moon"></i></button></div><nav class=sidebar_nav><ul><li><a href=/ class=nav_item>Home</a></li><li><a href=/posts/ class=nav_item>Posts</a></li><li><a href=/projects/ class=nav_item>Projects</a></li><li><a href=/tags/ class=nav_item>Tags</a></li></ul></nav><div class=sidebar_footer><div class="icons social_icons"><a href=https://www.youtube.com/@andrewsooter3745><i class="fa-brands fa-youtube"></i></a>
<a href=https://github.com/Andrewsooter442><i class="fa-brands fa-github"></i></a>
<a href=mailto:andrewsooter121@gmail.com><i class="fa-solid fa-envelope"></i></a>
<a href=https://www.linkedin.com/in/shashank-p906/><i class="fa-brands fa-linkedin"></i></a></div><div class=copyright><small>&copy; 2025</small></div></div></aside><main class=main_content><div class=Long_text><div class=post-container style="max-width:800px;margin:0 auto;width:100%"><h2 style=text-align:left;padding-left:0>Evolution-Sim</h2><div style=margin-bottom:2rem><p style=text-align:left;font-size:.9rem;color:var(--secondary-text);margin-bottom:.5rem>Nov 15, 2023</p></div><div class=content-body><p>I made this project as part of <a href=https://woc.sdslabs.co/>WOC</a> organized by <a href=https://sdslabs.co/>SDSLabs</a>.</p><p>It is a Python-based simulation where you can tweak the initial conditions and other parameters of an environment and then prey-predator adapt to each other and try to survive for a long time. (You are not playing GOD!)</p><h1 id=evolution-sim>Evolution-Sim</h1><blockquote><p>&ldquo;<a href=https://youtu.be/-wZjmAEtzoE>Watch this for a better understanding</a>&rdquo;</p></blockquote><div class=video-container><iframe src="https://www.youtube-nocookie.com/embed/ayHRo4aFl-s?autoplay=1&mute=1&rel=0" frameborder=0 allow="autoplay; encrypted-media" allowfullscreen loading=lazy></iframe></div><p><img src=./graph.png alt="Screenshot 2025-01-25 at 10.59.18 AM copy.png"></p><h3 id=algorithm-behind>Algorithm behind</h3><p>The underling algorithm that trains and which is responsible for the emergence of intelligence (<em>or stupidity in my case</em>) is the NEAT (neural evolution of argumented topology)</p><h5 id=neat-tldr>Neat tldr</h5><p>Unlike traditional machine learning approaches that require manually tuning hyperparameters such as learning rate, number of layers, and number of neurons in a neural network with a fixed topology, NEAT (NeuroEvolution of Augmenting Topologies) simultaneously evolves the structure and the parameters of the network. This means NEAT searches for both the optimal topology—adding or removing neurons and connections as needed—and the optimal weights and biases, enabling more flexible solutions that can adapt to the complexity of the problem without prior assumptions about the best architecture.</p><p><a href=https://nn.cs.utexas.edu/downloads/papers/stanley.cec02.pdf>Orignal Paper on NEAT</a></p><h3 id=initial-project-setup>Initial project setup</h3><h5 id=version-11-thing-wrong-with-this-version><em>Version 1.1</em> <a href=#version1-problems><em>Thing wrong with this version</em></a></h5><ul><li>World and movement<ul><li>The world is make up of cell where each entity occupies one cell</li><li>The entity can move in any of the four direction or decide to stay in the same cel in one frame.</li></ul></li><li>Decision-making<ul><li>The entity have different number of input and output neurons depending on the species they are from</li><li>They perceive the world around them by looking in the 4 directions and can see upto 4 block (<em>these parameters can be controlled by the user before the sim</em>) and the probability of the vision begin correct decreased the further we look (<em>though it&rsquo;s not a good idea</em>). [Read why](#Why it&rsquo;s not a good idea to use probablity for vision)</li><li>This world vision along with other parameters like there energy level, the biom they are in is passed in the neural network and the entity is controlled.</li></ul></li><li>Entity Energy<ul><li>Each entity has a reserve of energy that is spend on movement and existence.</li><li>The entity has enough energy to traverse the map diagonally twice and there energy can not exceed this limit.</li><li>If a entity runs out of energy they die.</li><li>For predator they gain energy by eating prey.</li><li>For prey they gain energy by staying still.</li></ul></li><li>Fitness calculation for prey<ul><li>For the prey, they start with a perfect fitness score and depending on how soon they die the score is subtracted from there perfect score also if they die of exertion they are less penalized they if they were to die to a predator (<em>survival of the fitness, but some skipped leg day!</em>)</li><li>The score to be reduced is weighted inversely to the time they lived.</li></ul></li><li>Fitness calculation for Predator<ul><li>For the predator they start with a zero fitness score and are rewarded some score if they eat a prey. [Read the exact method](#How predator gain energy)</li></ul></li></ul><h5 id=version-2><em>Version 2</em></h5><h3 id=trying-to-solve-performance-bottlenecks>Trying to solve performance bottlenecks</h3><ul><li>The initial implementation of the simulation had a significant performance bottleneck due to the sequential calculation of fitness for prey and predators. To address this issue, I decided to introduce multithreading to calculate the fitness of entities concurrently. This change should have helped improve the simulation&rsquo;s performance and make it more efficient.</li><li>However, after a long debugging session and learning how multiprocessing works in python, I realized that the neat-neural network is not picklable, which is a requirement for using the multiprocessing module. This limitation meant that I couldn&rsquo;t use multiprocessing for the fitness calculation, and I had to find an alternative solution to improve the simulation&rsquo;s performance.</li></ul><h3 id=creating-the-project-ui>Creating the project UI</h3><h3 id=version1-problems>Version1 problems</h3><ul><li><p><strong>Finding the optimal fitness calculation approach</strong></p><p>With the initial design of the simulation done and all the methods and functions working and tested. I wanted to entities to show complex behaviour like for predator chasing the prey and the prey escaping away, however the best I could get was the predators would go in the general direction where most of the prey were and the prey would go in the general direction where the predators were.</p><ul><li>I tried the following to fix this<ul><li>I removed the other way in which the entities could increase there fitness function and only kept there interation with the opposite species as a viable method of increasing it&rsquo;s fitness .</li><li>I also tried to increase the number of entities in the simulation to see if that would help the entities learn better behaviour and ran the simulations for longer (over 4500 generations).</li><li>I noticed that the entities would pile up at the edges of the map and not move from there, so I made the map so that the entities would wrap around the map when they reached the edge.</li><li>I also tried tweaking the parameters of the neural network to see if that would help the entities to better behaviour like.<ul><li>Changing the initial connections between input and output layers to be fully connected, partially connected and not connected at all.</li><li>Increasing the mutation rate of the neural network.</li><li>Using a different activation function for the neural network.</li></ul></li><li>I also tried to change the way the entities were placed on the map to see if that would help the entities learn better behaviour.<ul><li>I tried placing the entities in a grid like pattern.</li><li>I tried placing the entities in a random pattern.</li><li>I tried placing the entities in a random pattern with a bias towards the center of the map.</li></ul></li></ul></li><li>Having done all these, and each method taking a while to test, I think the problem is -<ul><li>The entities vision of there world</li><li>The grid based world</li></ul></li><li>After researching online and other places I found these methods that should get better results<ul><li>Using ray casting for the entities vision</li><li>Allowing the entities to move in any direction on the map rather than in a grid like pattern</li></ul></li></ul></li></ul></div><div style=margin-top:4rem;text-align:left><a href=.. style=font-size:1.1rem>← Go Back</a></div></div></div><footer class=page_footer><div class=Long_text></footer></main></div><script>const toggleButton=document.getElementById("theme-toggle"),icon=toggleButton.querySelector("i"),htmlElement=document.documentElement;htmlElement.getAttribute("data-theme")==="dark"&&(icon.classList.remove("fa-moon"),icon.classList.add("fa-sun")),toggleButton.addEventListener("click",()=>{let t=htmlElement.getAttribute("data-theme"),e=t==="dark"?"light":"dark";htmlElement.setAttribute("data-theme",e),localStorage.setItem("theme",e),e==="dark"?(icon.classList.remove("fa-moon"),icon.classList.add("fa-sun")):(icon.classList.remove("fa-sun"),icon.classList.add("fa-moon"))})</script></body></html>